# mysql的锁

**mysql根据加锁的范围，锁具体可以划分为全局锁、表锁、行锁**

## 1.全局锁

**全局锁就是对整个数据库实例加锁**，mysql通过Flush table with read lock(FTWRL)命令实现全局锁。**执行此命令之后，整个数据库就处于只读状态，其他线程的数据更新（增删改）操作、建表、修改表结构、和更新类事务的提交语句都会阻塞**

##### 适用场景：

​		全库逻辑备份

##### 注意:

​		既然要全库只读，为什么不使用 set global readonly = true 的方式？ 

- 一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，我不建议你使用。

- 二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。



## 2.表锁

**mysql的表锁有两种：表锁、元数据锁MDL（mata data lock）**

1. ##### 元数据锁

   元数据锁不需要显示使用，在访问表的时候被自动加上，作用是保证读写的正确性，防止一个线程在读取或者更新表t1数据的时候，其他线程修改t1的表结构。

   在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。读锁不互斥，但是读写锁互斥，从而保证操作的一致性。

   因为MDL的存在，所以更新表结构的时候需要注意避免死锁的出现：

   方法：1.执行alter语句的时候，先查询是否有长事务的存在，如果存在可以等长事务执行结束或者kill长事务的

   ​			2.给alter语句添加等待时长，如果在指定时间内拿到MDL写锁的时候，就执行alter语句，拿不到也不阻塞其他业务操作。

   ​			`ALTER TABLE tbl_name NOWAIT add column ...`

   ​			`ALTER TABLE tbl_name WAIT N add column ...` 

2. ##### 表锁

   表锁的语法：lock tables ... read/write

   eg: 1. lock  table t1 read 表示：所有线程都对表T1只能执行读取操作，不能进行更新操作

   ​	  2. lock table t2 write 表示：当前线程能执行t2表数据更新的操作，但是其他线程阻塞

   释放锁的方式：unlock tables 主动释放锁、或者客户端断开连接是自动释放。

## 3.行锁

**行锁就是针对数据表中行记录的锁。**mysql的行锁并不是所有的引擎都实现了，InnoDB支持，MyISAM不支持。

**在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。**

如下图：

事务 A 在执行完两条 update 语句后，持有哪些锁，以及在什么时候释放。你可以验证一下：实际上事务 B 的 update 语句会被阻塞，直到事务 A 执行 commit 之后，事务 B 才能继续执行。

<img src="C:\Users\zhanyu.gu\Desktop\享学\笔记\picture\mysql行锁1.jpg" alt="mysql行锁1" style="zoom:50%;" />

**死锁和死锁检测**

​		当并发系统中不同线程之间出现资源循环依赖，涉及的线程都在等待别的线程释放资源。就会导致这几个线程都陷入无线等待状态。

**死锁的解决策略：**

1. 设置死锁超时间，通过innodb_lock_wait_timeout（默认50s）设置超时时间。
2. 发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。innodb_deadlock_detect
   默认是开启（on）的。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。
3. 业务端做并发控制













