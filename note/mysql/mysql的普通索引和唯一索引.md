mysql的普通索引和唯一索引

mysql的普通索引和唯一索引的作用暂时不做主要讲解，这里主要介绍读取和更新的过程中两者的区别。

### 1.查询过程

#### 	查询语句

```mysql
select id from t_user where k = 6
```

​	普通索引：在查找满足条件的第一条记录之后，会继续查询下一条，直到查询到不满足k=6的记录。

​	唯一索引：在查找到第一条满足条件的记录之后，直接返回查询结果，停止继续检索。

从查询角度看，两者性能没有多大的区别。

### 2.更新过程

#### 	**change buffer**

​		在这里需要引入一个新的概念:change buffer,InnoDB的数据都是按数据页来读取的，也就是说在查询一条数据的时候，并不是将这条数据从磁盘中读出来，而是以页为单位，直接将行数据所在数据页加载到内存中。

​		当执行更新操作的时候，也是以数据页为单位进行更新操作。当需要更新一个数据页的时候，先判断数据页是否在内存中，如果在内存里则直接更新内存中数据页，如果这个数据页没有在内存中的话，InnoDB会将这个更新操作记录到change buffer中，这样无需从磁盘中读取这个数据页。当下一次查询的需要访问这个数据页的时候，就从磁盘中取出这个数据页，然后执行change buffer中与这个数据页有关的操作。

​		merge就是change buffer的数据应用到原数据页的操作，系统会定期触发merge操作，访问当前数据页的时候也能触发merge操作。流程如下：

​		1.从磁盘将原始数据页读入内存。

​		2.从change buffer中找出该数据页相关的change buffer,依次应用

​		3.写入redo log

​		change buffer也可以持久化数据。也会备份到磁盘上。

#### 	更新操作的对比

​	**唯一索引和普通索引再更新上的区别：**

​	假设需要更新记录的**目标数据页在内存中**：

​		唯一索引：在判断没有冲突之后，插入这个值。

​		普通索引：直接执行更新操作。

​	假设需要更新记录的**目标数据页不存在内存中**：

​		唯一索引：先将目标数据页读取到内存中（**I/O操作**），然后判断没有冲突之后，执行更新操作。

​		普通索引：将更新记录在change buffer。

**注意：数据库中最消耗性能的操作就是I/O，所以唯一索引在更新内存没有目标数据页操作的时候，会比普通索引消耗更多的性能。**

![image-20200617172717118](C:\Users\zhanyu.gu\AppData\Roaming\Typora\typora-user-images\image-20200617172717118.png)

#### 	change buffer的使用场景：

​		唯一索引不能使用change buffer，普通索引可以使用change buffer。

​		当然change buffer也并不是适用于所有普通索引的业务场景，如果是更新过后立马执行查询的业务场景，反而会起到反向作用。因为change buffer在更新操作之后，立刻查询的话会触发merge，产生mysql的I/O操作。而change buffer中的记录只有少数几条，这样change buffer的使用效率会很低。

**注意redo log与change buffer的区别:**

​		两者都是为了减少数据库的I/O消耗，但是redo log是为了减少mysql的写磁盘的IO消耗，而change buffer是为了减少mysql的读磁盘的IO操作。























